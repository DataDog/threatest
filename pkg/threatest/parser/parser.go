// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package parser

import "encoding/json"
import "fmt"

// Configuration of an Atomic Red Team test case
type AtomicRedTeamSchemaJson struct {
	// Inputs for the Atomic Red Team test case
	Inputs AtomicRedTeamSchemaJsonInputs `json:"inputs,omitempty" yaml:"inputs,omitempty" mapstructure:"inputs,omitempty"`

	// Atomic Red Team test case name
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// MITRE ATT&CK technique ID
	Technique string `json:"technique" yaml:"technique" mapstructure:"technique"`
}

// Inputs for the Atomic Red Team test case
type AtomicRedTeamSchemaJsonInputs map[string]string

// Definition of an AWS CLI detonation
type AwsCliDetonatorSchemaJson struct {
	// Script corresponds to the JSON schema field "script".
	Script *string `json:"script,omitempty" yaml:"script,omitempty" mapstructure:"script,omitempty"`
}

// Matcher for a Datadog security signal
type DatadogSecuritySignalSchemaJson struct {
	// Name of the Datadog signal to match on (exact match)
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Severity of the Datadog signal to match on
	Severity *string `json:"severity,omitempty" yaml:"severity,omitempty" mapstructure:"severity,omitempty"`
}

// Definition of a local command detonation
type LocalDetonatorSchemaJson struct {
	// AtomicReadTeam corresponds to the JSON schema field "atomicReadTeam".
	AtomicReadTeam *AtomicRedTeamSchemaJson `json:"atomicReadTeam,omitempty" yaml:"atomicReadTeam,omitempty" mapstructure:"atomicReadTeam,omitempty"`

	// Commands corresponds to the JSON schema field "commands".
	Commands []string `json:"commands,omitempty" yaml:"commands,omitempty" mapstructure:"commands,omitempty"`
}

// Definition of a remote command detonation
type RemoteDetonatorSchemaJson struct {
	// AtomicReadTeam corresponds to the JSON schema field "atomicReadTeam".
	AtomicReadTeam *AtomicRedTeamSchemaJson `json:"atomicReadTeam,omitempty" yaml:"atomicReadTeam,omitempty" mapstructure:"atomicReadTeam,omitempty"`

	// Commands corresponds to the JSON schema field "commands".
	Commands []string `json:"commands,omitempty" yaml:"commands,omitempty" mapstructure:"commands,omitempty"`
}

// Definition of a Stratus Red Team detonator
type StratusRedTeamDetonatorSchemaJson struct {
	// Attack technique ID of the Stratus Red Team technique to detonate (per
	// https://stratus-red-team.cloud/attack-techniques/list/)
	AttackTechnique *string `json:"attackTechnique,omitempty" yaml:"attackTechnique,omitempty" mapstructure:"attackTechnique,omitempty"`
}

// How to detonate the attack
type ThreatestSchemaJsonScenariosElemDetonate struct {
	// AwsCliDetonator corresponds to the JSON schema field "awsCliDetonator".
	AwsCliDetonator *AwsCliDetonatorSchemaJson `json:"awsCliDetonator,omitempty" yaml:"awsCliDetonator,omitempty" mapstructure:"awsCliDetonator,omitempty"`

	// LocalDetonator corresponds to the JSON schema field "localDetonator".
	LocalDetonator *LocalDetonatorSchemaJson `json:"localDetonator,omitempty" yaml:"localDetonator,omitempty" mapstructure:"localDetonator,omitempty"`

	// RemoteDetonator corresponds to the JSON schema field "remoteDetonator".
	RemoteDetonator *RemoteDetonatorSchemaJson `json:"remoteDetonator,omitempty" yaml:"remoteDetonator,omitempty" mapstructure:"remoteDetonator,omitempty"`

	// StratusRedTeamDetonator corresponds to the JSON schema field
	// "stratusRedTeamDetonator".
	StratusRedTeamDetonator *StratusRedTeamDetonatorSchemaJson `json:"stratusRedTeamDetonator,omitempty" yaml:"stratusRedTeamDetonator,omitempty" mapstructure:"stratusRedTeamDetonator,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AtomicRedTeamSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in AtomicRedTeamSchemaJson: required")
	}
	if v, ok := raw["technique"]; !ok || v == nil {
		return fmt.Errorf("field technique in AtomicRedTeamSchemaJson: required")
	}
	type Plain AtomicRedTeamSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AtomicRedTeamSchemaJson(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatadogSecuritySignalSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in DatadogSecuritySignalSchemaJson: required")
	}
	type Plain DatadogSecuritySignalSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DatadogSecuritySignalSchemaJson(plain)
	return nil
}

// Expectations
type ThreatestSchemaJsonScenariosElemExpectationsElem struct {
	// DatadogSecuritySignal corresponds to the JSON schema field
	// "datadogSecuritySignal".
	DatadogSecuritySignal *DatadogSecuritySignalSchemaJson `json:"datadogSecuritySignal,omitempty" yaml:"datadogSecuritySignal,omitempty" mapstructure:"datadogSecuritySignal,omitempty"`

	// The maximal time to wait for the assertion, written as a Go duration (e.g. 5m)
	Timeout string `json:"timeout,omitempty" yaml:"timeout,omitempty" mapstructure:"timeout,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThreatestSchemaJsonScenariosElemExpectationsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ThreatestSchemaJsonScenariosElemExpectationsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["timeout"]; !ok || v == nil {
		plain.Timeout = "5m"
	}
	*j = ThreatestSchemaJsonScenariosElemExpectationsElem(plain)
	return nil
}

// The list of scenarios
type ThreatestSchemaJsonScenariosElem struct {
	// How to detonate the attack
	Detonate ThreatestSchemaJsonScenariosElemDetonate `json:"detonate" yaml:"detonate" mapstructure:"detonate"`

	// Expectations corresponds to the JSON schema field "expectations".
	Expectations []ThreatestSchemaJsonScenariosElemExpectationsElem `json:"expectations" yaml:"expectations" mapstructure:"expectations"`

	// Description of the scenario
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThreatestSchemaJsonScenariosElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["detonate"]; !ok || v == nil {
		return fmt.Errorf("field detonate in ThreatestSchemaJsonScenariosElem: required")
	}
	if v, ok := raw["expectations"]; !ok || v == nil {
		return fmt.Errorf("field expectations in ThreatestSchemaJsonScenariosElem: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ThreatestSchemaJsonScenariosElem: required")
	}
	type Plain ThreatestSchemaJsonScenariosElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ThreatestSchemaJsonScenariosElem(plain)
	return nil
}

// Schema for a Threatest test suite
type ThreatestSchemaJson struct {
	// The display name of the vulnerability
	Scenarios []ThreatestSchemaJsonScenariosElem `json:"scenarios" yaml:"scenarios" mapstructure:"scenarios"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThreatestSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["scenarios"]; !ok || v == nil {
		return fmt.Errorf("field scenarios in ThreatestSchemaJson: required")
	}
	type Plain ThreatestSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ThreatestSchemaJson(plain)
	return nil
}
