// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package parser

import "fmt"
import "encoding/json"

// Matcher for a Datadog security signal
type DatadogSecuritySignalSchemaJson struct {
	// Name of the Datadog signal to match on (exact match)
	Name string `json:"name"`

	// Severity of the Datadog signal to match on
	Severity *string `json:"severity,omitempty"`
}

// Definition of a local command detonation
type LocalDetonatorSchemaJson struct {
	// Commands corresponds to the JSON schema field "commands".
	Commands []string `json:"commands,omitempty"`
}

// Definition of a remote command detonation
type RemoteDetonatorSchemaJson struct {
	// Commands corresponds to the JSON schema field "commands".
	Commands []string `json:"commands,omitempty"`
}

// Definition of a Stratus Red Team detonator
type StratusRedTeamDetonatorSchemaJson struct {
	// Attack technique ID of the Stratus Red Team technique to detonate (per
	// https://stratus-red-team.cloud/attack-techniques/list/)
	AttackTechnique *string `json:"attackTechnique,omitempty"`
}

// How to detonate the attack
type ThreatestSchemaJsonScenariosElemDetonate struct {
	// LocalDetonator corresponds to the JSON schema field "localDetonator".
	LocalDetonator *LocalDetonatorSchemaJson `json:"localDetonator,omitempty"`

	// RemoteDetonator corresponds to the JSON schema field "remoteDetonator".
	RemoteDetonator *RemoteDetonatorSchemaJson `json:"remoteDetonator,omitempty"`

	// StratusRedTeamDetonator corresponds to the JSON schema field
	// "stratusRedTeamDetonator".
	StratusRedTeamDetonator *StratusRedTeamDetonatorSchemaJson `json:"stratusRedTeamDetonator,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatadogSecuritySignalSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain DatadogSecuritySignalSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DatadogSecuritySignalSchemaJson(plain)
	return nil
}

// Expectations
type ThreatestSchemaJsonScenariosElemExpectationsElem struct {
	// DatadogSecuritySignal corresponds to the JSON schema field
	// "datadogSecuritySignal".
	DatadogSecuritySignal *DatadogSecuritySignalSchemaJson `json:"datadogSecuritySignal,omitempty"`

	// The maximal time to wait for the assertion, written as a Go duration (e.g. 5m)
	Timeout string `json:"timeout,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThreatestSchemaJsonScenariosElemExpectationsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ThreatestSchemaJsonScenariosElemExpectationsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["timeout"]; !ok || v == nil {
		plain.Timeout = "5m"
	}
	*j = ThreatestSchemaJsonScenariosElemExpectationsElem(plain)
	return nil
}

// The list of scenarios
type ThreatestSchemaJsonScenariosElem struct {
	// How to detonate the attack
	Detonate ThreatestSchemaJsonScenariosElemDetonate `json:"detonate"`

	// Expectations corresponds to the JSON schema field "expectations".
	Expectations []ThreatestSchemaJsonScenariosElemExpectationsElem `json:"expectations"`

	// Description of the scenario
	Name string `json:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThreatestSchemaJsonScenariosElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["detonate"]; !ok || v == nil {
		return fmt.Errorf("field detonate: required")
	}
	if v, ok := raw["expectations"]; !ok || v == nil {
		return fmt.Errorf("field expectations: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain ThreatestSchemaJsonScenariosElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ThreatestSchemaJsonScenariosElem(plain)
	return nil
}

// Schema for a Threatest test suite
type ThreatestSchemaJson struct {
	// The display name of the vulnerability
	Scenarios []ThreatestSchemaJsonScenariosElem `json:"scenarios"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThreatestSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["scenarios"]; !ok || v == nil {
		return fmt.Errorf("field scenarios: required")
	}
	type Plain ThreatestSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ThreatestSchemaJson(plain)
	return nil
}
